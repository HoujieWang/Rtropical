cbind(con, matrix(NA, nrow =24, ncol = 3), f,con)
cbind(con, matrix(NA, nrow =24, ncol = 3), f.con)
library(e1071); library(lpSolve); library(lpSolveAPI); library(parallel); library(Rfast); library(RcppAlgos);
e = 10; n = 2; N = 100; s = 10
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
newx = rbind(rmvnorm(N, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(N, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
newy = as.factor(rep(c(1, 2), each = N))
tropFW = function(x){
nn = nrow(x)
e = ncol(x)
jk = comboGeneral(1: e, 2)
combn_size = nrow(jk)
conY = matrix(0, nrow = nn*combn_size, ncol = e)
all_v = x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] = -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] = 1
conD = matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] = -1
con = cbind(conD, rbind(conY, -conY))
rhs = c(matrix(all_v), -matrix(all_v))
obj = c(rep(1, nn), rep(0, e))
dir = rep("<=", (2*nn*combn_size))
sol = lp("min", obj, con, dir, rhs)
list("centroid" = sol$solution[-c(1: nn)], "obj" = sol$objval)
}
fermatweberdistance <- function(datamatrix) {
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
return((get.objective(lprec)))
}
centroid_finder = function(tconv){
# tconv = t(x)
# tconv = t(data[1: n1, ])
e = nrow(tconv); s = ncol(tconv)
f.obj = c(rep(0, e), rep(1, s))
jk = combn(1:e, 2)
f.conA = matrix(0, nrow = s*choose(e, 2), ncol = e)
for (i in 1: choose(e, 2)){
f.conA[(1+(i-1)*s): (i*s), rep(jk[1, i], 2)] = 1
f.conA[(1+(i-1)*s): (i*s), rep(jk[2, i], 2)] = -1
}
f.conA = cbind(f.conA, do.call(rbind, replicate(choose(e, 2), diag(1, nrow = s, ncol = s), simplify = F)))
f.conB = f.conA
f.conB[,(e+1):(e+s)] = -f.conB[,(e+1):(e+s)]
f.con = rbind(f.conA, f.conB)
f.rhs = matrix(apply(jk, 2, function(x){tconv[x[1], ] - tconv[x[2], ]}))
f.rhs = rep(f.rhs, 2)
f.dir = rep(c(">=", "<="), each = s*choose(e, 2))
sol = lp("min", f.obj, f.con, f.dir, f.rhs)
return(list("centroid" = sol$solution[1: e], "obj" = sol$objval))
}
tropFW(x)
fermatweberdistance(x)
centroid_finder(t(x))
library(e1071); library(lpSolve); library(lpSolveAPI); library(parallel); library(Rfast); library(RcppAlgos);
e = 100; n = 10; N = 100; s = 10
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
newx = rbind(rmvnorm(N, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(N, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
newy = as.factor(rep(c(1, 2), each = N))
tropFW = function(x){
nn = nrow(x)
e = ncol(x)
jk = comboGeneral(1: e, 2)
combn_size = nrow(jk)
conY = matrix(0, nrow = nn*combn_size, ncol = e)
all_v = x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] = -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] = 1
conD = matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] = -1
con = cbind(conD, rbind(conY, -conY))
rhs = c(matrix(all_v), -matrix(all_v))
obj = c(rep(1, nn), rep(0, e))
dir = rep("<=", (2*nn*combn_size))
sol = lp("min", obj, con, dir, rhs)
list("centroid" = sol$solution[-c(1: nn)], "obj" = sol$objval)
}
fermatweberdistance <- function(datamatrix) {
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
return((get.objective(lprec)))
}
centroid_finder = function(tconv){
# tconv = t(x)
# tconv = t(data[1: n1, ])
e = nrow(tconv); s = ncol(tconv)
f.obj = c(rep(0, e), rep(1, s))
jk = combn(1:e, 2)
f.conA = matrix(0, nrow = s*choose(e, 2), ncol = e)
for (i in 1: choose(e, 2)){
f.conA[(1+(i-1)*s): (i*s), rep(jk[1, i], 2)] = 1
f.conA[(1+(i-1)*s): (i*s), rep(jk[2, i], 2)] = -1
}
f.conA = cbind(f.conA, do.call(rbind, replicate(choose(e, 2), diag(1, nrow = s, ncol = s), simplify = F)))
f.conB = f.conA
f.conB[,(e+1):(e+s)] = -f.conB[,(e+1):(e+s)]
f.con = rbind(f.conA, f.conB)
f.rhs = matrix(apply(jk, 2, function(x){tconv[x[1], ] - tconv[x[2], ]}))
f.rhs = rep(f.rhs, 2)
f.dir = rep(c(">=", "<="), each = s*choose(e, 2))
sol = lp("min", f.obj, f.con, f.dir, f.rhs)
return(list("centroid" = sol$solution[1: e], "obj" = sol$objval))
}
tropFW(x)
fermatweberdistance(x)
centroid_finder(t(x))
library(e1071); library(lpSolve); library(lpSolveAPI); library(parallel); library(Rfast); library(RcppAlgos);
e = 10; n = 10; N = 100; s = 10
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
newx = rbind(rmvnorm(N, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(N, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
newy = as.factor(rep(c(1, 2), each = N))
tropFW = function(x){
nn = nrow(x)
e = ncol(x)
jk = comboGeneral(1: e, 2)
combn_size = nrow(jk)
conY = matrix(0, nrow = nn*combn_size, ncol = e)
all_v = x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] = -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] = 1
conD = matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] = -1
con = cbind(conD, rbind(conY, -conY))
rhs = c(matrix(all_v), -matrix(all_v))
obj = c(rep(1, nn), rep(0, e))
dir = rep("<=", (2*nn*combn_size))
sol = lp("min", obj, con, dir, rhs)
list("centroid" = sol$solution[-c(1: nn)], "obj" = sol$objval)
}
fermatweberdistance <- function(datamatrix) {
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
return((get.objective(lprec)))
}
centroid_finder = function(tconv){
# tconv = t(x)
# tconv = t(data[1: n1, ])
e = nrow(tconv); s = ncol(tconv)
f.obj = c(rep(0, e), rep(1, s))
jk = combn(1:e, 2)
f.conA = matrix(0, nrow = s*choose(e, 2), ncol = e)
for (i in 1: choose(e, 2)){
f.conA[(1+(i-1)*s): (i*s), rep(jk[1, i], 2)] = 1
f.conA[(1+(i-1)*s): (i*s), rep(jk[2, i], 2)] = -1
}
f.conA = cbind(f.conA, do.call(rbind, replicate(choose(e, 2), diag(1, nrow = s, ncol = s), simplify = F)))
f.conB = f.conA
f.conB[,(e+1):(e+s)] = -f.conB[,(e+1):(e+s)]
f.con = rbind(f.conA, f.conB)
f.rhs = matrix(apply(jk, 2, function(x){tconv[x[1], ] - tconv[x[2], ]}))
f.rhs = rep(f.rhs, 2)
f.dir = rep(c(">=", "<="), each = s*choose(e, 2))
sol = lp("min", f.obj, f.con, f.dir, f.rhs)
return(list("centroid" = sol$solution[1: e], "obj" = sol$objval))
}
tropFW(x)
fermatweberdistance(x)
centroid_finder(t(x))
library(rbenchmark)
benchmark(
tropFW(x),
fermatweberdistance(x),
centroid_finder(t(x)), replications = 5)
library(e1071); library(lpSolve); library(lpSolveAPI); library(parallel); library(Rfast); library(RcppAlgos); library(rbenchmark)
e = 10; n = 100; N = 100; s = 10
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
newx = rbind(rmvnorm(N, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(N, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
newy = as.factor(rep(c(1, 2), each = N))
tropFW = function(x){
nn = nrow(x)
e = ncol(x)
jk = comboGeneral(1: e, 2)
combn_size = nrow(jk)
conY = matrix(0, nrow = nn*combn_size, ncol = e)
all_v = x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] = -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] = 1
conD = matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] = -1
con = cbind(conD, rbind(conY, -conY))
rhs = c(matrix(all_v), -matrix(all_v))
obj = c(rep(1, nn), rep(0, e))
dir = rep("<=", (2*nn*combn_size))
sol = lp("min", obj, con, dir, rhs)
list("centroid" = sol$solution[-c(1: nn)], "obj" = sol$objval)
}
fermatweberdistance <- function(datamatrix) {
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
return((get.objective(lprec)))
}
centroid_finder = function(tconv){
# tconv = t(x)
# tconv = t(data[1: n1, ])
e = nrow(tconv); s = ncol(tconv)
f.obj = c(rep(0, e), rep(1, s))
jk = combn(1:e, 2)
f.conA = matrix(0, nrow = s*choose(e, 2), ncol = e)
for (i in 1: choose(e, 2)){
f.conA[(1+(i-1)*s): (i*s), rep(jk[1, i], 2)] = 1
f.conA[(1+(i-1)*s): (i*s), rep(jk[2, i], 2)] = -1
}
f.conA = cbind(f.conA, do.call(rbind, replicate(choose(e, 2), diag(1, nrow = s, ncol = s), simplify = F)))
f.conB = f.conA
f.conB[,(e+1):(e+s)] = -f.conB[,(e+1):(e+s)]
f.con = rbind(f.conA, f.conB)
f.rhs = matrix(apply(jk, 2, function(x){tconv[x[1], ] - tconv[x[2], ]}))
f.rhs = rep(f.rhs, 2)
f.dir = rep(c(">=", "<="), each = s*choose(e, 2))
sol = lp("min", f.obj, f.con, f.dir, f.rhs)
return(list("centroid" = sol$solution[1: e], "obj" = sol$objval))
}
benchmark(
tropFW(x),
fermatweberdistance(x),
centroid_finder(t(x)), replications = 5)
library(e1071); library(lpSolve); library(lpSolveAPI); library(parallel); library(Rfast); library(RcppAlgos); library(rbenchmark)
e = 20; n = 100; N = 100; s = 10
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
newx = rbind(rmvnorm(N, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(N, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
newy = as.factor(rep(c(1, 2), each = N))
tropFW = function(x){
nn = nrow(x)
e = ncol(x)
jk = comboGeneral(1: e, 2)
combn_size = nrow(jk)
conY = matrix(0, nrow = nn*combn_size, ncol = e)
all_v = x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] = -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] = 1
conD = matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] = -1
con = cbind(conD, rbind(conY, -conY))
rhs = c(matrix(all_v), -matrix(all_v))
obj = c(rep(1, nn), rep(0, e))
dir = rep("<=", (2*nn*combn_size))
sol = lp("min", obj, con, dir, rhs)
list("centroid" = sol$solution[-c(1: nn)], "obj" = sol$objval)
}
fermatweberdistance <- function(datamatrix) {
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
return((get.objective(lprec)))
}
centroid_finder = function(tconv){
# tconv = t(x)
# tconv = t(data[1: n1, ])
e = nrow(tconv); s = ncol(tconv)
f.obj = c(rep(0, e), rep(1, s))
jk = combn(1:e, 2)
f.conA = matrix(0, nrow = s*choose(e, 2), ncol = e)
for (i in 1: choose(e, 2)){
f.conA[(1+(i-1)*s): (i*s), rep(jk[1, i], 2)] = 1
f.conA[(1+(i-1)*s): (i*s), rep(jk[2, i], 2)] = -1
}
f.conA = cbind(f.conA, do.call(rbind, replicate(choose(e, 2), diag(1, nrow = s, ncol = s), simplify = F)))
f.conB = f.conA
f.conB[,(e+1):(e+s)] = -f.conB[,(e+1):(e+s)]
f.con = rbind(f.conA, f.conB)
f.rhs = matrix(apply(jk, 2, function(x){tconv[x[1], ] - tconv[x[2], ]}))
f.rhs = rep(f.rhs, 2)
f.dir = rep(c(">=", "<="), each = s*choose(e, 2))
sol = lp("min", f.obj, f.con, f.dir, f.rhs)
return(list("centroid" = sol$solution[1: e], "obj" = sol$objval))
}
benchmark(
tropFW(x),
fermatweberdistance(x),
centroid_finder(t(x)), replications = 1)
library(e1071); library(lpSolve); library(lpSolveAPI); library(parallel); library(Rfast); library(RcppAlgos); library(rbenchmark)
e = 20; n = 100; N = 100; s = 10
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
newx = rbind(rmvnorm(N, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(N, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
newy = as.factor(rep(c(1, 2), each = N))
tropFW = function(x){
nn = nrow(x)
e = ncol(x)
jk = comboGeneral(1: e, 2)
combn_size = nrow(jk)
conY = matrix(0, nrow = nn*combn_size, ncol = e)
all_v = x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] = -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] = 1
conD = matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] = -1
con = cbind(conD, rbind(conY, -conY))
rhs = c(matrix(all_v), -matrix(all_v))
obj = c(rep(1, nn), rep(0, e))
dir = rep("<=", (2*nn*combn_size))
sol = lp("min", obj, con, dir, rhs)
list("centroid" = sol$solution[-c(1: nn)], "obj" = sol$objval)
}
fermatweberdistance <- function(datamatrix) {
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
return((get.objective(lprec)))
}
centroid_finder = function(tconv){
# tconv = t(x)
# tconv = t(data[1: n1, ])
e = nrow(tconv); s = ncol(tconv)
f.obj = c(rep(0, e), rep(1, s))
jk = combn(1:e, 2)
f.conA = matrix(0, nrow = s*choose(e, 2), ncol = e)
for (i in 1: choose(e, 2)){
f.conA[(1+(i-1)*s): (i*s), rep(jk[1, i], 2)] = 1
f.conA[(1+(i-1)*s): (i*s), rep(jk[2, i], 2)] = -1
}
f.conA = cbind(f.conA, do.call(rbind, replicate(choose(e, 2), diag(1, nrow = s, ncol = s), simplify = F)))
f.conB = f.conA
f.conB[,(e+1):(e+s)] = -f.conB[,(e+1):(e+s)]
f.con = rbind(f.conA, f.conB)
f.rhs = matrix(apply(jk, 2, function(x){tconv[x[1], ] - tconv[x[2], ]}))
f.rhs = rep(f.rhs, 2)
f.dir = rep(c(">=", "<="), each = s*choose(e, 2))
sol = lp("min", f.obj, f.con, f.dir, f.rhs)
return(list("centroid" = sol$solution[1: e], "obj" = sol$objval))
}
tropFW(x)
fermatweberdistance(x)
centroid_finder(t(x))
install.packages("cplex")
install.packages("Rcplex")
install.packages("Rcplex")
library(Rcplex)
install.packages("Rcplex", repos = "http://R-Forge.R-project.org/projects/rcplex")
?install_github
library(devtools)
install_github("https://github.com/cran/Rcplex")
pkgbuild::check_build_tools(debug = TRUE)
install.packages("/Users/wanghoujie/Downloads/Rcplex_0.3-3.tar", repos = NULL, type = "source")
devtools::check("Rcplex")
install.packages("Rcplex", repos="http://R-Forge.R-project.org")
install.packages("Rcplex")
install.packages("Rcplex", repos="http://R-Forge.R-project.org")
install.packages("/Users/wanghoujie/Downloads/Rcplex_0.3-3.tar", repos = NULL, type = "source")
install("cplexAPI")
install.packages("cplexAPI")
install.packages("cplexAPI")
config.log
install.packages("Rcpp")
install.packages("Rcpp")
library(Rcpp)
install.packages("cplex")
install.packages("cplexAPI")
library(ape)
rtree(n)
rtree(m)
library(Rtropical)
sapply(1: 3, function(i){vec.fun(rtree(5))})
?rtree
rcoal
rmtree(N, 5, br = "coalescent")
rmtree(20, 5, br = "coalescent")
multiPhylo.to.data.matrix(rmtree(20, 5, br = "coalescent"))
sapply(rmtree(20, 5, br = "coalescent"), vec.fun)
warnings()
rmtree(20, 5, br = "coalescent")[[1]]
aa = rmtree(20, 5, br = "coalescent")[[1]]
aa
vec.fun(aa)
cophenetic.phylo(aa)
tree <- rcoal(5)
vec.fun(tree)
install.packages(:ape)
install.packages("ape")
install.packages("ape")
library(Rtropical)
?cophenetic
library(Rtropical)
library(ape)
pltp <- sapply(1: 3, function(i){vec.fun(rcoal(5))})
tree <- rcoal(5)
tree_vec <- vec.fun(tree)
project_pi(tree_vec, pltp)
troproj(tree_vec, pltp)
library(Rtropical)
pltp <- sapply(1: 3, function(i){vec.fun(rcoal(5))})
tree <- rcoal(5)
tree_vec <- vec.fun(tree)
troproj(tree_vec, pltp)
aa = troproj(tree_vec, pltp) - pltp[, 1]
max(aa)-min(aa)
library(Rtropical)
library(Rcpp)
library(RcppAlgos)
