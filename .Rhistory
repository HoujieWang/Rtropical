n
n <- 100; e <- 5; sig2 <- 1
x <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)))
V = tropca_fit$pc
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
all_j = c(1: e)[-tau]
temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
x = x[1, ]
temp2
x = x[1, ]
x = x[1, ]
V = tropca_fit$pc
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
x
data_proj = matrix(0, nrow = n, ncol = e)
x
data_proj
i = 1
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
all_tau
tau = all_tau[[1]]
tau
all_j = c(1: e)[-tau]
all_j
x[, all_j]
all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))]
eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
rowMins(temp_block, T)
temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
rowMins(temp_block, T)
tropdet(V[, c(tau, i)])
x[, all_j]
all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))]
x
class(x[, all_j])
as.matrix(x[, all_j])
all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))]
?as.matrix()
all_j
tau
matrix(x[, all_j], ncol = e-pcs+1)
matrix(x[, all_j], ncol = e-pcs+1, byrow = TRUE)
temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1, byrow = TRUE), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
temp_block
rowMins(temp_block, T) + tropdet(V[, c(tau, i)])
library(Rtropical)
library(Rfast)
library(RcppAlgos)
n <- 100; e <- 5; sig2 <- 1
x <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)))
V = x[1: 3, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
tau = all_tau[[1]]
all_j = c(1: e)[-tau]
temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1, byrow = TRUE), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
identical(data_proj[1: 3, ], V)
data_proj[1: 3, ]
V
V = x[1: 3, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
tau = all_tau[[1]]
all_j = c(1: e)[-tau]
temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
# temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1, byrow = TRUE), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
identical(data_proj[1: 3, ], V)
troproj.linsp(x, x[1: 3, ])
data_proj = troproj.linsp(x, x[1: 3, ])
head(data_proj)
x[1: 3, ]
identical(data_proj[1: 3, ], x[1: 3, ])
data_proj[1: 3, ]
x[1: 3, ]
sum(abs(data_proj[1: 3, ] - x[1: 3, ]))
V = x[1: 3, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
tau = all_tau[[1]]
all_j = c(1: e)[-tau]
# temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1, byrow = TRUE), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
sum(abs(data_proj[1: 3, ] - x[1: 3, ]))
V = x[1: 3, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
tau = all_tau[[1]]
all_j = c(1: e)[-tau]
# temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
sum(abs(data_proj[1: 3, ] - x[1: 3, ]))
e-pcs+1
all_j
x[, all_j]
as.vector(x[, all_j])
sum(abs(matrix(x[, all_j], ncol = e-pcs+1) - x[, all_j]))
n <- 100; e <- 5; sig2 <- 1
x <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)))
V = x[1: 3, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
tau = all_tau[[1]]
all_j = c(1: e)[-tau]
# temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
sum(abs(data_proj[1: 3, ] - x[1: 3, ]))
V = x[1: 3, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
i = 1
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
V = x[1: 3, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
# tau = all_tau[[1]]
all_j = c(1: e)[-tau]
# temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
sum(abs(data_proj[1: 3, ] - x[1: 3, ]))
V = x[1: 3, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
# tau = all_tau[[1]]
all_j = c(1: e)[-tau]
# temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
sum(abs(data_proj[1: 3, ] - x[1: 3, ]))
V = x[1: 3, ]
x = x[1, ]
if(is.vector(x)) x = t(as.matrix(x))
n = nrow(x); pcs = nrow(V); e = ncol(x);
all_dets = array(NA, dim = c(e-2, e-1, e))
all_combns = comboGeneral(1: e, pcs)
all_combns_list = lapply(1: nrow(all_combns), function(i){all_combns[i, ]})
all_dets[all_combns] = unlist(lapply(all_combns_list, function(i){tropdet(V[, i])}))
data_proj = matrix(0, nrow = n, ncol = e)
for (i in 1: e){
# i = 1
all_tau = comboGeneral(c(1: e)[-i], pcs - 1)
all_tau = lapply(1: nrow(all_tau), function(i){all_tau[i, ]})
temp2 = lapply(all_tau, function(tau){
# tau = all_tau[[1]]
all_j = c(1: e)[-tau]
# temp_block = eachrow(x[, all_j], all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
temp_block = eachrow(matrix(x[, all_j], ncol = e-pcs+1), all_dets[rowSort(cbind(all_j, matrix(tau, ncol = 2, nrow = (e-pcs+1), byrow = T)))], "-")
return(rowMins(temp_block, T) + tropdet(V[, c(tau, i)]))
})
temp2 = do.call(cbind, temp2)
data_proj[, i] = rowMaxs(temp2, T)
}
data_proj
x[1, ]
library(Rtropical)
rm(llist = ls())
rm(list = ls())
if (Sys.getenv("RSTUDIO") == "1" && !nzchar(Sys.getenv("RSTUDIO_TERM")) &&
Sys.info()["sysname"] == "Darwin" && getRversion() >= "4.0.0") {
parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
}
library(Rtropical)
library(Rfast)
library(RcppAlgos)
n <- 100; e <- 5; sig2 <- 1
x <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)))
tropFW(x)
tropca_fit <- tropca.linsp(x)
tropca_fit
troproj.linsp(x[1, ], tropca_fit$pc)
troproj.linsp(x, tropca_fit$pc)
library(Rtropical)
library(Rtropical)
library(Rtropical)
library(Rfast)
library(RcppAlgos)
n <- 100; e <- 5; sig2 <- 1
x <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)))
tropca_fit <- tropca(x)
tropca_fit$pc
plot(tropca_fit)
if (Sys.getenv("RSTUDIO") == "1" && !nzchar(Sys.getenv("RSTUDIO_TERM")) &&
Sys.info()["sysname"] == "Darwin" && getRversion() >= "4.0.0") {
parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
}
library(Rtropical)
library(Rfast)
library(RcppAlgos)
n <- 100; e <- 5; sig2 <- 1
x <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)))
tropca_fit <- tropca(x)
tropca_fit$pc
plot(tropca_fit)
x2 <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(sig2, e)),
rmvnorm(n, mu = c(0, 5, -5, rep(0, e-3)), sigma = diag(sig2, e)))
labels <- as.factor(rep(1: 3, each = n))
tropca_fit2 <- tropca(x2)
plot(tropca_fit2, plab = labels)
tropca_fit <- tropca.linsp(x)
plot(tropca_fit)
labels <- as.factor(rep(letters[1: 3], each = n))
plot(tropca_fit2, plab = labels)
n <- 100; e <- 5; sig2 <- 1
x <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)))
?prcomp
tropca_lp <- tropca.linsp(x)
n <- 100; e <- 5; sig2 <- 1
x <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)))
tropca_lp <- tropca.linsp(x)
troproj.linsp(x, tropca_lp$pc)
tropca_lp <- tropca.linsp(x)
tropca_lp
tropca_lp$pc
troproj.linsp(x[1, ], tropca_lp$pc)
tropca_mcmc <- tropca(x)
tropca_mcmc$pc
plot(tropca_mcmc)
x2 <- rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(sig2, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(sig2, e)),
rmvnorm(n, mu = c(0, 5, -5, rep(0, e-3)), sigma = diag(sig2, e)))
labels <- as.factor(rep(letters[1: 3], each = n))
tropca_mcmc2 <- tropca(x2)
plot(tropca_mcmc2, plab = labels)
troproj(x[1, ], t(tropca_fit$pc))
tropFW(x)
tropca_mcmc2$obj
tropFW(x)$obj/(tropFW(x)$obj+tropca_mcmc$obj)
563.3999/(563.3999+645.5148)
summary(prcomp(x))
tropca_lp$obj
tropFW(tropca_mcmc$projection)
tropFW(tropca_lp$projection)
tropca_lp$obj
559.7035/(559.7035+118.6271)
tropFW(x)
# This function is used for calculating R-Square
fermatweberdistance <- function(datamatrix) {
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
return((get.objective(lprec)))
}
fermatweberdistance(x)
library(lpSolveAPI)
fermatweberdistance(x)
tropca_lp
tropFW(tropca_lp$projection)
sum(rowMaxs(x - tropca_lp$projection, value = T) - rowMins(x - tropca_lp$projection, value = T))
save(x, file = "PCAexample1.RData")
save(x2, file = "PCAexample2.RData")
tropdet
library(Rtropical)
?trop_det2d
?base_and_recommended()
library(usethis)
?base_and_recommended()
?base_and_recommended
library(glmnet)
?lambda.interp
lambda.interp
library(Rtropical)
library(Rtropical)
plot(tropca_mcmc)
plot(tropca_mcmc2, plab = labels)
library(Rtropical)
?dets
library(Rtropical)
tropca(x)
if (Sys.getenv("RSTUDIO") == "1" && !nzchar(Sys.getenv("RSTUDIO_TERM")) &&
Sys.info()["sysname"] == "Darwin" && getRversion() >= "4.0.0") {
parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
}
tropca(x)
library(Rtropical)
?tropdet
R = matrix(sample(1: 9, 9), nrow = 3)
R
library(lpSolve)
lp.assign(R, "max")
R
permuteGeneral(1: 3)
permuteCount(1: 3)
idx = permuteGeneral(1: 3)
temp = c()
for (i in 1: permuteCount(1: 3)){
temp = c(temp, sum(R[cbind(1: nrow(R), idx[i, ])]))
}
temp
lp.assign(R, "max")
idx = permuteGeneral(1: 3)
temp = c()
for (i in 1: permuteCount(1: 3)){
temp = c(temp, sum(R[cbind(1: nrow(R), idx[i, ])]))
}
idx = permuteGeneral(1: 3)
temp = c()
for (i in 1: permuteCount(1: 3)){
temp = c(temp, sum(R[cbind(1: nrow(R), idx[i, ])]))
}
temp
idx = permuteGeneral(1: 3)
temp = c()
for (i in 1: permuteCount(1: 3)){
temp = c(temp, sum(R[cbind(1: nrow(R), idx[i, ])]))
}
temp
R = matrix(sample(1: 9, 9), nrow = 3)
lp.assign(R, "max")
idx = permuteGeneral(1: 3)
temp = c()
for (i in 1: permuteCount(1: 3)){
temp = c(temp, sum(R[cbind(1: nrow(R), idx[i, ])]))
}
temp
R = matrix(sample(1: 9, 9), nrow = 3)
lp.assign(R, "max")
idx = permuteGeneral(1: 3)
temp = c()
for (i in 1: permuteCount(1: 3)){
temp = c(temp, sum(R[cbind(1: nrow(R), idx[i, ])]))
}
temp
R = matrix(sample(1: 9, 9), nrow = 3)
lp.assign(R, "max")
idx = permuteGeneral(1: 3)
temp = c()
for (i in 1: permuteCount(1: 3)){
temp = c(temp, sum(R[cbind(1: nrow(R), idx[i, ])]))
}
temp
R = matrix(sample(1: 9, 9), nrow = 3)
lp.assign(R, "max")
idx = permuteGeneral(1: 3)
temp = c()
for (i in 1: permuteCount(1: 3)){
temp = c(temp, sum(R[cbind(1: nrow(R), idx[i, ])]))
}
temp
lp.assign
obj = lp.assign(R, "max")
obj$costs
?lp.assign()
obj$rcount
obj$ccount
temp
obj$rrhs
obj$int.count
lp.assign(R, "min")
obj$crhs
?tropdet
R = matrix(sample(1: 9, 9), nrow = 3)
tropdet(R)
?tropdet
