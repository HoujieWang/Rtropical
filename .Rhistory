rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
s1 = Sys.time()
lp1 = fermatweberdistance(x)
e1 = Sys.time()
s2 = Sys.time()
lp2 = tropFW2(x)
e2 = Sys.time()
e1 - s1
e2 - s2
lp1[[2]] - lp2[[2]]
e = 10; n = 5; s = 5
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
nn = nrow(x)
fermatweberdistance <- function(datamatrix, constraint = FALSE){
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
tropFW2 = function(x, constraint = FALSE){
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
s1 = Sys.time()
lp1 = fermatweberdistance(x)
e1 = Sys.time()
s2 = Sys.time()
lp2 = tropFW2(x)
e2 = Sys.time()
e1 - s1
e2 - s2
lp1[[2]] - lp2[[2]]
e = 10; n = 5; s = 5
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
nn = nrow(x)
fermatweberdistance <- function(datamatrix, constraint = FALSE){
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
tropFW2 = function(x, constraint = FALSE){
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
s1 = Sys.time()
lp1 = fermatweberdistance(x)
e1 = Sys.time()
s2 = Sys.time()
lp2 = tropFW2(x)
e2 = Sys.time()
e1 - s1
e2 - s2
lp1[[2]] - lp2[[2]]
e = 10; n = 5; s = 5
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
nn = nrow(x)
fermatweberdistance <- function(datamatrix, constraint = FALSE){
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
tropFW2 = function(x, constraint = FALSE){
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
s1 = Sys.time()
lp1 = fermatweberdistance(x)
e1 = Sys.time()
s2 = Sys.time()
lp2 = tropFW2(x)
e2 = Sys.time()
e1 - s1
e2 - s2
lp1[[2]] - lp2[[2]]
e = 100; n = 5; s = 5
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
nn = nrow(x)
fermatweberdistance <- function(datamatrix, constraint = FALSE){
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
tropFW2 = function(x, constraint = FALSE){
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
if (constraint){lprec}
else{list("sol" = sols, "distsum" = sum(sols[1: nn]))}
}
s1 = Sys.time()
lp1 = fermatweberdistance(x)
e1 = Sys.time()
s2 = Sys.time()
lp2 = tropFW2(x)
e2 = Sys.time()
e1 - s1
e2 - s2
lp1[[2]] - lp2[[2]]
e = 100; n = 5; s = 5
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
nn = nrow(x)
fermatweberdistance <- function(datamatrix){
n = dim(datamatrix)[1]
m = dim(datamatrix)[2]
lprec <- make.lp(0, n+m)
objective = mat.or.vec(n+m,1)
for (i in seq(n)) {
objective[i] = 1
}
set.objfn(lprec, objective)
for (i in seq(n)) {
for (j in seq(m)) {
for (k in seq(m)) {
v = mat.or.vec(n+m,1)
v[i] = 1
v[n+k] = 1
v[n+j] = -1
add.constraint(lprec, v, ">=", datamatrix[i,k] - datamatrix[i,j])
}
}
}
solve(lprec)
sols = get.variables(lprec)
list("fw" = sols[-c(1: n)], "distsum" = sum(sols[1: nn]))
}
tropFW2 = function(x){
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
list("fw" = sols[-c(1: nn)], "distsum" = sum(sols[1: nn]))
}
s1 = Sys.time()
lp1 = fermatweberdistance(x)
e1 = Sys.time()
s2 = Sys.time()
lp2 = tropFW2(x)
e2 = Sys.time()
e1 - s1
e2 - s2
lp1[[2]] - lp2[[2]]
rm(list = ls())
source("/Users/wanghoujie/Downloads/Research/Tropical/R pack for SVM & PCA/Code/func_ssh1.R")
library(Rfast); library(lpSolve); library(lpSolveAPI); library(RcppAlgos); library(rbenchmark); library(foreach)
e = 100; n = 5; s = 5
x = rbind(rmvnorm(n, mu = c(5, -5, rep(0, e-2)), sigma = diag(s, e)),
rmvnorm(n, mu = c(-5, 5, rep(0, e-2)), sigma = diag(s, e)))
y = as.factor(c(rep(1, n), rep(2, n)))
nn = nrow(x)
tropFW2 = function(x){
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
list("fw" = sols[-c(1: nn)], "distsum" = sum(sols[1: nn]))
}
s1 = Sys.time()
lp1 = fermatweberdistance(x)
e1 = Sys.time()
s2 = Sys.time()
lp2 = tropFW2(x)
e2 = Sys.time()
e1 - s1
e2 - s2
lp1 - lp2[[2]]
lp1
lp2
lp1
lp2
profvis::profvis(
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
list("fw" = sols[-c(1: nn)], "distsum" = sum(sols[1: nn]))
)
profvis::profvis(
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
sols = get.variables(lprec)
list("fw" = sols[-c(1: nn)], "distsum" = sum(sols[1: nn]))
)
profvis::profvis({
nn <- nrow(x)
e <- ncol(x)
jk <- comboGeneral(1: e, 2)
combn_size <- nrow(jk)
obj <- c(rep(1, nn), rep(0, e))
conY <- matrix(0, nrow = nn*combn_size, ncol = e)
all_v <- x[, jk[, 2]] - x[, jk[, 1]]
conY[cbind(1: (nn*combn_size), rep(jk[, 1], each = nrow(x)))] <- -1
conY[cbind(1: (nn*combn_size), rep(jk[, 2], each = nrow(x)))] <- 1
conD <- matrix(0, nrow = 2*nn*combn_size, ncol = nn)
conD[cbind(1: (2*nn*combn_size), 1: nn)] <- -1
con <- cbind(conD, rbind(conY, -conY))
conD_2 <- matrix(0, nrow = nn*e, ncol = nn)
conD_2[cbind(1: (nn*e), 1: nn)] <- -1
conY_2 <- matrix(0, nrow = nn*e, ncol = e)
conY_2[cbind(1: (nn*e), rep(1: e, each = nn))] <- 1
con_2 <- cbind(conD_2, conY_2)
con_new <- rbind(con, con_2)
rhs_new <- c(matrix(all_v), -matrix(all_v), rep(0, (nn*e)))
dir_new <- rep("<=", (2*nn*combn_size + (nn*e)))
lprec <- make.lp(nrow(con_new), nn+e)
for (i in 1: ncol(con_new)){set.column(lprec, i, -con_new[, i])}
set.constr.type(lprec, rep(">=", (2*nn*combn_size + (nn*e))))
set.rhs(lprec, -rhs_new)
set.objfn(lprec, c(rep(1, nn), rep(0, e)))
solve(lprec)
})
library(Rtropical)
library(Rtropical)
tropFW()
tropFW
