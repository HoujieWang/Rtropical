svmpredict
cv.svmmodel <- cv.tropsvm(x, y, nassignment = 10, parallel = TRUE, ncores = 4)
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
cv.svmpredict
tropsvm2 <- function(x, y, auto.assignment = FALSE, assignment = NULL, ind = 1){
classes <- unique(y)
reorder_ind <- c(which(y == classes[1]), which(y == classes[2]))
label <- y[reorder_ind]
data <- x[reorder_ind, ]
n1 <- sum(label == classes[1])
n2 <- sum(label == classes[2])
n <- n1 + n2
if (auto.assignment){
assignment <- assignment_finder(data[1: n1, ], data[-c(1: n1), ])[1, ]
}
names(assignment) = c("ip", "iq", "jp", "jq")
ip <- assignment[1]; jp <- assignment[3]; iq <- assignment[2]; jq <- assignment[4]
f.obj <- c(1, rep(0, 4), c(rep(-1, n1), rep(-1, n1), rep(-1, n1), rep(-1, n1), rep(-1, n2),
rep(-1, n2), rep(-1, n2), rep(-1, n2)))
f.conp <- rbind(cbind(rep(1, n1), rep(-1, n1), rep(1, n1), rep(0, n1), rep(0, n1)),
cbind(rep(0, n1), rep(-1, n1), rep(1, n1), rep(0, n1), rep(0, n1)),
cbind(rep(0, n1), rep(0, n1), rep(-1, n1), rep(1, n1), rep(0, n1)),
cbind(rep(0, n1), rep(0, n1), rep(-1, n1), rep(0, n1), rep(1, n1)))
f.conq <- rbind(cbind(rep(1, n2), rep(0, n2), rep(0, n2), rep(-1, n2), rep(1, n2)),
cbind(rep(0, n2), rep(0, n2), rep(0, n2), rep(-1, n2), rep(1, n2)),
cbind(rep(0, n2), rep(1, n2), rep(0, n2), rep(0, n2), rep(-1, n2)),
cbind(rep(0, n2), rep(0, n2), rep(1, n2), rep(0, n2), rep(-1, n2)))
f.con <- cbind(rbind(f.conp, f.conq), diag(-1, nrow = 4*n, ncol = 4*n))
f.dir <- rep("<=", n)
f.rhs = c(rep(data[1: n1, ip] - data[1: n1, jp], 2),
data[1: n1, jp] - data[1: n1, iq],
data[1: n1, jp] - data[1: n1, jq],
rep(data[-c(1: n1), iq] - data[-c(1: n1), jq], 2),
data[-c(1: n1), jq] - data[-c(1: n1), ip],
data[-c(1: n1), jq] - data[-c(1: n1), jp])
omega <- rep(0, ncol(data))
sol <- lp("max", f.obj, f.con, f.dir, f.rhs)
omega[c(ip, jp, iq, jq)] <- sol$solution[2: 5]
omega[-c(ip, jp, iq, jq)] <- colMins(-data[, -c(ip, jp, iq, jq)] + c(data[1: n1, jp] + omega[jp], data[-c(1: n1), jq] + omega[jq]), T)
tropsvm.out <- list("apex" = omega,
"assignment" = assignment,
"index" = ind,
"levels" = as.factor(classes))
class(tropsvm.out) <- "tropsvm"
tropsvm.out
}
svm_fit = svm(x, y)
sum(predict(svm_fit, newx) == newy)/length(newy)
svmmodel <- tropsvm(x, y, auto.assignment = TRUE)
svmpredict <- predict(svmmodel, newx)
sum(as.vector(svmpredict) == newy)/length(newy)
tropsvm2 <- function(x, y, auto.assignment = FALSE, assignment = NULL, ind = 1){
classes <- unique(y)
reorder_ind <- c(which(y == classes[1]), which(y == classes[2]))
label <- y[reorder_ind]
data <- x[reorder_ind, ]
n1 <- sum(label == classes[1])
n2 <- sum(label == classes[2])
n <- n1 + n2
if (auto.assignment){
assignment <- assignment_finder(data[1: n1, ], data[-c(1: n1), ])[1, ]
}
names(assignment) = c("ip", "iq", "jp", "jq")
ip <- assignment[1]; jp <- assignment[3]; iq <- assignment[2]; jq <- assignment[4]
f.obj <- c(1, rep(0, 4), c(rep(-1, n1), rep(-1, n1), rep(-1, n1), rep(-1, n1), rep(-1, n2),
rep(-1, n2), rep(-1, n2), rep(-1, n2)))
f.conp <- rbind(cbind(rep(1, n1), rep(-1, n1), rep(1, n1), rep(0, n1), rep(0, n1)),
cbind(rep(0, n1), rep(-1, n1), rep(1, n1), rep(0, n1), rep(0, n1)),
cbind(rep(0, n1), rep(0, n1), rep(-1, n1), rep(1, n1), rep(0, n1)),
cbind(rep(0, n1), rep(0, n1), rep(-1, n1), rep(0, n1), rep(1, n1)))
f.conq <- rbind(cbind(rep(1, n2), rep(0, n2), rep(0, n2), rep(-1, n2), rep(1, n2)),
cbind(rep(0, n2), rep(0, n2), rep(0, n2), rep(-1, n2), rep(1, n2)),
cbind(rep(0, n2), rep(1, n2), rep(0, n2), rep(0, n2), rep(-1, n2)),
cbind(rep(0, n2), rep(0, n2), rep(1, n2), rep(0, n2), rep(-1, n2)))
f.con <- cbind(rbind(f.conp, f.conq), diag(-1, nrow = 4*n, ncol = 4*n))
f.dir <- rep("<=", n)
f.rhs = c(rep(data[1: n1, ip] - data[1: n1, jp], 2),
data[1: n1, jp] - data[1: n1, iq],
data[1: n1, jp] - data[1: n1, jq],
rep(data[-c(1: n1), iq] - data[-c(1: n1), jq], 2),
data[-c(1: n1), jq] - data[-c(1: n1), ip],
data[-c(1: n1), jq] - data[-c(1: n1), jp])
omega <- rep(0, ncol(data))
sol <- lp("max", f.obj, f.con, f.dir, f.rhs)
omega[c(ip, jp, iq, jq)] <- sol$solution[2: 5]
omega[-c(ip, jp, iq, jq)] <- colMins(-data[, -c(ip, jp, iq, jq)] + c(data[1: n1, jp] + omega[jp], data[-c(1: n1), jq] + omega[jq]), T)
tropsvm.out <- list("apex" = omega,
"assignment" = assignment,
"index" = ind,
"levels" = as.factor(classes))
class(tropsvm.out) <- "tropsvm"
tropsvm.out
}
svmmodel <- tropsvm2(x, y, auto.assignment = TRUE)
svmpredict <- predict(svmmodel, newx)
sum(as.vector(svmpredict) == newy)/length(newy)
tropsvm_helper <- function(x, y,  assignment = NULL, ind = 1, newx = NULL, newy = NULL){
# x = data; y = label; newx = val_data; newy = val_label
classes <- unique(y)
reorder_ind <- c(which(y == classes[1]), which(y == classes[2]))
label <- y[reorder_ind]
data <- x[reorder_ind, ]
n1 <- sum(label == classes[1])
n2 <- sum(label == classes[2])
n <- n1 + n2
names(assignment) = c("ip", "iq", "jp", "jq")
ip <- assignment[1]; jp <- assignment[3]; iq <- assignment[2]; jq <- assignment[4]
f.obj <- c(1, rep(0, 4), c(rep(-1, n1), rep(-1, n1), rep(-1, n1), rep(-1, n1), rep(-1, n2),
rep(-1, n2), rep(-1, n2), rep(-1, n2)))
f.conp <- rbind(cbind(rep(1, n1), rep(-1, n1), rep(1, n1), rep(0, n1), rep(0, n1)),
cbind(rep(0, n1), rep(-1, n1), rep(1, n1), rep(0, n1), rep(0, n1)),
cbind(rep(0, n1), rep(0, n1), rep(-1, n1), rep(1, n1), rep(0, n1)),
cbind(rep(0, n1), rep(0, n1), rep(-1, n1), rep(0, n1), rep(1, n1)))
f.conq <- rbind(cbind(rep(1, n2), rep(0, n2), rep(0, n2), rep(-1, n2), rep(1, n2)),
cbind(rep(0, n2), rep(0, n2), rep(0, n2), rep(-1, n2), rep(1, n2)),
cbind(rep(0, n2), rep(1, n2), rep(0, n2), rep(0, n2), rep(-1, n2)),
cbind(rep(0, n2), rep(0, n2), rep(1, n2), rep(0, n2), rep(-1, n2)))
f.con <- cbind(rbind(f.conp, f.conq), diag(-1, nrow = 4*n, ncol = 4*n))
f.dir <- rep("<=", n)
f.rhs = c(rep(data[1: n1, ip] - data[1: n1, jp], 2),
data[1: n1, jp] - data[1: n1, iq],
data[1: n1, jp] - data[1: n1, jq],
rep(data[-c(1: n1), iq] - data[-c(1: n1), jq], 2),
data[-c(1: n1), jq] - data[-c(1: n1), ip],
data[-c(1: n1), jq] - data[-c(1: n1), jp])
reorder_ind <- c(which(newy == classes[1]), which(newy == classes[2]))
val_label <- newy[reorder_ind]
val_data <- newx[reorder_ind, ]
val_n1 <- sum(val_label == classes[1])
omega <- rep(0, ncol(data))
omega[c(ip, jp, iq, jq)] <- lp("max", f.obj, f.con, f.dir, f.rhs)$solution[2: 5]
omega[-c(ip, jp, iq, jq)] <- colMins(-data[, -c(ip, jp, iq, jq)] + c(data[1: n1, jp] + omega[jp], data[-c(1: n1), jq] + omega[jq]), T)
shifted_val_data <- eachrow(val_data, omega, "+")
diff <- eachrow(t(shifted_val_data), rowMaxs(shifted_val_data, T), oper = "-")
raw_classification <- lapply(lapply(seq_len(ncol(diff)), function(i) diff[, i]), function(x){which(abs(x) < 1e-10)})
if (length(unique(assignment)) == 2){
accuracy <- (sum(raw_classification[1: val_n1] == ip)+sum(raw_classification[-c(1: val_n1)] == iq))/length(raw_classification)
} else{
all_method_ind <- comboGeneral(8, 4)
# Algorithm 1
if (length(unique(assignment)) == 4){
P_base <- matrix(c(1, 0, 0, 0,
0, 1, 0, 0,
1, 1, 0, 0,
1, 1, 1, 1), ncol = 4, byrow = T);
Q_base <- matrix(c(0, 0, 1, 0,
0, 0, 0, 1,
0, 0, 1, 1,
0, 0, 0, 0), ncol = 4, byrow = T);
PQ_com <- matrix(c(1, 0, 1, 0,
1, 0, 0, 1,
0, 1, 1, 0,
0, 1, 0, 1,
1, 1, 1, 0,
1, 1, 0, 1,
1, 0, 1, 1,
0, 1, 1, 1), ncol = 4, byrow = T)
}
if (length(unique(assignment)) == 3){
P_base <- c(); Q_base <- c()
PQ_com <- matrix(c(1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1,
1, 1, 1,
0, 0, 0), ncol = 3, byrow = T)
if (ip == jq){
PQ_com <- PQ_com[, c(1, 2, 3, 1)]
}
if (iq == jp){
PQ_com <- PQ_com[, c(1, 2, 2, 3)]
}
if (jp == jq){
PQ_com <- PQ_com[, c(1, 2, 3, 2)]
}
}
colnames(PQ_com) <- c("ip", "jp", "iq", "jq")
accuracy <- sapply(ind, function(l){
P = rbind(P_base, PQ_com[all_method_ind[l, ], ]); Q = rbind(Q_base, PQ_com[-all_method_ind[l, ], ])
sum(c(sapply(raw_classification[1: val_n1], function(x){
v = c(ip, jp, iq, jq) %in% x;
return(sum(colSums(t(P) == v) == ncol(P)))
}), sapply(raw_classification[-c(1: val_n1)], function(x){
v = c(ip, jp, iq, jq) %in% x;
return(sum(colSums(t(Q) == v) == ncol(Q)))
})))/length(raw_classification)
})
}
accuracy
}
cv.tropsvm2 <- function(x, y, parallel = FALSE, nfold = 10, nassignment = 10, ncores = 2){
if (nrow(x) != length(y)){
stop("numbers of data and label don't match")
}
if (length(unique(y)) != 2){
stop("only two classes allowded")
}
if (is.data.frame(x)){
warning("input data not 'matrix'; set to 'Matrix'")
x <- data.matrix(x)
}
if (nassignment < 10){
warning("too few possible assignments to validate, please choose at least 10")
}
classes <- unique(y)
reorder_ind <- c(which(y == classes[1]), which(y == classes[2]))
np = sum(y == classes[1]); nq = sum(y == classes[1])
y <- y[reorder_ind]
x <- x[reorder_ind, ]
train_index <- createFolds(y, k = nfold, returnTrain = TRUE)
all_assignment <- matrix(0, nrow = nfold*nassignment, ncol = 4)
for (i in 1: length(train_index)){
P = x[train_index[[i]] <= np, ]
Q = x[train_index[[i]] > np, ]
all_assignment[((i-1)*nassignment+1): (i*nassignment), ] = assignment_finder(P, Q)[1: nassignment, ]
}
all_assignment = unique(all_assignment)
all_assignment_list = lapply(seq_len(nrow(all_assignment)), function(i) all_assignment[i, ])
all_accuracy_list <- list()
cl <- makeCluster(ncores)
for (i in 1: length(train_index)){
# i = 1
data <- x[train_index[[i]], ]
label <- y[train_index[[i]]]
n1 <- sum(label == classes[1])
n2 <- sum(label == classes[2])
n <- n1 + n2
val_data <- x[-train_index[[i]], ]
val_label <- y[-train_index[[i]]]
val_n1 <- sum(val_label == classes[1])
val_n2 <- sum(val_label == classes[2])
val_n <- val_n1 + val_n2
if (parallel){
all_accuracy <- parLapply(cl, all_assignment_list, function(assignment){
tropsvm_helper(x = data, y = label, accuracy = T, assignment = assignment, ind = 1: 70, newx = val_data, newy = val_label)})
} else{
all_accuracy <- lapply(all_assignment_list, function(assignment){tropsvm_helper(data, label, accuracy = T, assignment = assignment, ind = 1: 70, newx = val_data, newy = val_label)})
}
accuracy_mat <- do.call("rbind", all_accuracy)
all_accuracy_list[[i]] <- accuracy_mat
}
stopCluster(cl)
all_accuracy_mat <- Reduce("+", all_accuracy_list)
best_hyperparms <- matrix(which(all_accuracy_mat == max(all_accuracy_mat), arr.ind = T)[1, ], ncol = 2, byrow = TRUE)
best_assignment <- all_assignment[best_hyperparms[1, 1], ]
best_method_ind <- best_hyperparms[1, 2]
best_accuracy <- sapply(all_accuracy_list, max)
best_fold <- which.max(sapply(all_accuracy_list, function(x){x[best_hyperparms]}))
data <- x[train_index[[best_fold]], ]
label <- y[train_index[[best_fold]]]
n1 <- sum(label == classes[1])
n2 <- sum(label == classes[2])
n <- n1 + n2
val_data <- x[-train_index[[best_fold]], ]
val_label <- y[-train_index[[best_fold]]]
val_n1 <- sum(val_label == classes[1])
val_n2 <- sum(val_label == classes[2])
val_n <- val_n1 + val_n2
tropsvm.out <- tropsvm2(data, label, assignment = best_assignment, ind = best_method_ind)
cv.tropsvm.out <- list("apex" = tropsvm.out$apex,
"assignment" = best_assignment,
"index" = best_method_ind,
"levels" = as.factor(classes),
"accuracy" = best_accuracy,
"nfold" = nfold)
class(cv.tropsvm.out) <- "cv.tropsvm"
cv.tropsvm.out
}
cv.svmmodel2 <- cv.tropsvm2(x, y, nassignment = 10)
cv.tropsvm2 <- function(x, y, parallel = FALSE, nfold = 10, nassignment = 10, ncores = 2){
if (nrow(x) != length(y)){
stop("numbers of data and label don't match")
}
if (length(unique(y)) != 2){
stop("only two classes allowded")
}
if (is.data.frame(x)){
warning("input data not 'matrix'; set to 'Matrix'")
x <- data.matrix(x)
}
if (nassignment < 10){
warning("too few possible assignments to validate, please choose at least 10")
}
classes <- unique(y)
reorder_ind <- c(which(y == classes[1]), which(y == classes[2]))
np = sum(y == classes[1]); nq = sum(y == classes[1])
y <- y[reorder_ind]
x <- x[reorder_ind, ]
train_index <- createFolds(y, k = nfold, returnTrain = TRUE)
all_assignment <- matrix(0, nrow = nfold*nassignment, ncol = 4)
for (i in 1: length(train_index)){
P = x[train_index[[i]] <= np, ]
Q = x[train_index[[i]] > np, ]
all_assignment[((i-1)*nassignment+1): (i*nassignment), ] = assignment_finder(P, Q)[1: nassignment, ]
}
all_assignment = unique(all_assignment)
all_assignment_list = lapply(seq_len(nrow(all_assignment)), function(i) all_assignment[i, ])
all_accuracy_list <- list()
cl <- makeCluster(ncores)
for (i in 1: length(train_index)){
# i = 1
data <- x[train_index[[i]], ]
label <- y[train_index[[i]]]
n1 <- sum(label == classes[1])
n2 <- sum(label == classes[2])
n <- n1 + n2
val_data <- x[-train_index[[i]], ]
val_label <- y[-train_index[[i]]]
val_n1 <- sum(val_label == classes[1])
val_n2 <- sum(val_label == classes[2])
val_n <- val_n1 + val_n2
if (parallel){
all_accuracy <- parLapply(cl, all_assignment_list, function(assignment){
tropsvm_helper(x = data, y = label, accuracy = T, assignment = assignment, ind = 1: 70, newx = val_data, newy = val_label)})
} else{
all_accuracy <- lapply(all_assignment_list, function(assignment){tropsvm_helper(data, label, assignment = assignment, ind = 1: 70, newx = val_data, newy = val_label)})
}
accuracy_mat <- do.call("rbind", all_accuracy)
all_accuracy_list[[i]] <- accuracy_mat
}
stopCluster(cl)
all_accuracy_mat <- Reduce("+", all_accuracy_list)
best_hyperparms <- matrix(which(all_accuracy_mat == max(all_accuracy_mat), arr.ind = T)[1, ], ncol = 2, byrow = TRUE)
best_assignment <- all_assignment[best_hyperparms[1, 1], ]
best_method_ind <- best_hyperparms[1, 2]
best_accuracy <- sapply(all_accuracy_list, max)
best_fold <- which.max(sapply(all_accuracy_list, function(x){x[best_hyperparms]}))
data <- x[train_index[[best_fold]], ]
label <- y[train_index[[best_fold]]]
n1 <- sum(label == classes[1])
n2 <- sum(label == classes[2])
n <- n1 + n2
val_data <- x[-train_index[[best_fold]], ]
val_label <- y[-train_index[[best_fold]]]
val_n1 <- sum(val_label == classes[1])
val_n2 <- sum(val_label == classes[2])
val_n <- val_n1 + val_n2
tropsvm.out <- tropsvm2(data, label, assignment = best_assignment, ind = best_method_ind)
cv.tropsvm.out <- list("apex" = tropsvm.out$apex,
"assignment" = best_assignment,
"index" = best_method_ind,
"levels" = as.factor(classes),
"accuracy" = best_accuracy,
"nfold" = nfold)
class(cv.tropsvm.out) <- "cv.tropsvm"
cv.tropsvm.out
}
cv.svmmodel2 <- cv.tropsvm2(x, y, nassignment = 10)
cv.svmpredict <- predict(cv.svmmodel2, newx)
sum(cv.svmpredict == newy)/length(newy)
n <- 100; N <- 100; e <- 500; s <- 2
x <- rbind(rmvnorm(n, mu = c(rep(0, e-2), 5, -5), sigma = diag(s, e)),
rmvnorm(n, mu = c(rep(0, e-2), -5, 5), sigma = diag(s, e)))
y <- as.factor(rep(c(1, 2), each = n))
newx <- rbind(rmvnorm(N, mu = c(rep(0, e-2), 5, -5), sigma = diag(s, e)),
rmvnorm(N, mu = c(rep(0, e-2), -5, 5), sigma = diag(s, e)))
newy <- as.factor(rep(c(1, 2), each = N))
svm_fit = svm(x, y)
sum(predict(svm_fit, newx) == newy)/length(newy)
# accu1 = c(accu1, sum(predict(svm_fit, newx) == newy)/length(newy))
# print(accu1)
svmmodel <- tropsvm(x, y, auto.assignment = TRUE)
svmpredict <- predict(svmmodel, newx)
sum(as.vector(svmpredict) == newy)/length(newy)
svmmodel <- tropsvm2(x, y, auto.assignment = TRUE)
svmpredict <- predict(svmmodel, newx)
sum(as.vector(svmpredict) == newy)/length(newy)
# accu2 = c(accu2, sum(as.vector(svmpredict) == newy)/length(newy))
# print(accu2)
cv.svmmodel <- cv.tropsvm(x, y, nassignment = 10)
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
cv.svmmodel2 <- cv.tropsvm2(x, y, nassignment = 10)
cv.svmpredict <- predict(cv.svmmodel2, newx)
sum(cv.svmpredict == newy)/length(newy)
library(Rtropical)
library(Rtropical)
library(Rtropical)
library(Rfast)
library(lpSolve)
library(caret)
library(RcppAlgos)
library(e1071)
library(parallel)
library(ape)
n <- 100; N <- 100; e <- 500; s <- 2
x <- rbind(rmvnorm(n, mu = c(rep(0, e-2), 5, -5), sigma = diag(s, e)),
rmvnorm(n, mu = c(rep(0, e-2), -5, 5), sigma = diag(s, e)))
y <- as.factor(rep(c(1, 2), each = n))
newx <- rbind(rmvnorm(N, mu = c(rep(0, e-2), 5, -5), sigma = diag(s, e)),
rmvnorm(N, mu = c(rep(0, e-2), -5, 5), sigma = diag(s, e)))
newy <- as.factor(rep(c(1, 2), each = N))
svm_fit = svm(x, y)
sum(predict(svm_fit, newx) == newy)/length(newy)
# accu1 = c(accu1, sum(predict(svm_fit, newx) == newy)/length(newy))
# print(accu1)
svmmodel <- tropsvm(x, y, auto.assignment = TRUE)
svmpredict <- predict(svmmodel, newx)
sum(as.vector(svmpredict) == newy)/length(newy)
# accu2 = c(accu2, sum(as.vector(svmpredict) == newy)/length(newy))
# print(accu2)
cv.svmmodel <- cv.tropsvm(x, y)
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
setwd("~/Downloads/Research/Tropical/All Tree Data")
C = 0.2
name1 = paste("Tree", C, "A.txt", sep = ""); name2 = paste("Tree", C, "B.txt", sep = "")
P = read.tree(name1); Q = read.tree(name2)
all_data = matrix(unlist(lapply(append(P,Q),
function(x){cophenetic.phylo(x)[lower.tri(cophenetic.phylo(x))]})), nrow = 300, byrow = T)
labels = as.factor(rep(c(1, 2), each = 150))
all_data = cbind.data.frame(class = labels, all_data)
dta = all_data
trn_ind = sample(1: nrow(dta), 300*0.8)
# save(trn_ind, file = "trn_ind0.2.RData")
x = as.matrix(dta[trn_ind, -1])
y = dta[trn_ind, 1]
newx = as.matrix(dta[-trn_ind, -1])
newy = dta[-trn_ind, 1]
svm_fit = svm(x, y)
sum(predict(svm_fit, newx) == newy)/length(newy)
# accu1 = c(accu1, sum(predict(svm_fit, newx) == newy)/length(newy))
# print(accu1)
svmmodel <- tropsvm(x, y, auto.assignment = TRUE)
svmpredict <- predict(svmmodel, newx)
sum(as.vector(svmpredict) == newy)/length(newy)
# accu2 = c(accu2, sum(as.vector(svmpredict) == newy)/length(newy))
# print(accu2)
cv.svmmodel <- cv.tropsvm(x, y)
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
start = Sys.time()
cv.svmmodel <- cv.tropsvm(x, y, nassignment = 500)
end = Sys.time()
end - start
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
start = Sys.time()
cv.svmmodel <- cv.tropsvm(x, y, nassignment = 500, parallel = TRUE, ncores = 4)
end = Sys.time()
end - start
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
C = 0.4
C = 0.4
name1 = paste("Tree", C, "A.txt", sep = ""); name2 = paste("Tree", C, "B.txt", sep = "")
P = read.tree(name1); Q = read.tree(name2)
all_data = matrix(unlist(lapply(append(P,Q),
function(x){cophenetic.phylo(x)[lower.tri(cophenetic.phylo(x))]})), nrow = 300, byrow = T)
labels = as.factor(rep(c(1, 2), each = 150))
all_data = cbind.data.frame(class = labels, all_data)
dta = all_data
trn_ind = sample(1: nrow(dta), 300*0.8)
# save(trn_ind, file = "trn_ind0.2.RData")
x = as.matrix(dta[trn_ind, -1])
y = dta[trn_ind, 1]
newx = as.matrix(dta[-trn_ind, -1])
newy = dta[-trn_ind, 1]
svm_fit = svm(x, y)
sum(predict(svm_fit, newx) == newy)/length(newy)
# accu1 = c(accu1, sum(predict(svm_fit, newx) == newy)/length(newy))
# print(accu1)
svmmodel <- tropsvm(x, y, auto.assignment = TRUE)
svmpredict <- predict(svmmodel, newx)
sum(as.vector(svmpredict) == newy)/length(newy)
# accu2 = c(accu2, sum(as.vector(svmpredict) == newy)/length(newy))
# print(accu2)
start = Sys.time()
cv.svmmodel <- cv.tropsvm(x, y, nassignment = 1000, parallel = TRUE, ncores = 4)
end = Sys.time()
end - start
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
cv.svmmodel
C = 1
name1 = paste("Tree", C, "A.txt", sep = ""); name2 = paste("Tree", C, "B.txt", sep = "")
P = read.tree(name1); Q = read.tree(name2)
all_data = matrix(unlist(lapply(append(P,Q),
function(x){cophenetic.phylo(x)[lower.tri(cophenetic.phylo(x))]})), nrow = 300, byrow = T)
labels = as.factor(rep(c(1, 2), each = 150))
all_data = cbind.data.frame(class = labels, all_data)
dta = all_data
trn_ind = sample(1: nrow(dta), 300*0.8)
# save(trn_ind, file = "trn_ind0.2.RData")
x = as.matrix(dta[trn_ind, -1])
y = dta[trn_ind, 1]
newx = as.matrix(dta[-trn_ind, -1])
newy = dta[-trn_ind, 1]
svm_fit = svm(x, y)
sum(predict(svm_fit, newx) == newy)/length(newy)
# accu1 = c(accu1, sum(predict(svm_fit, newx) == newy)/length(newy))
# print(accu1)
svmmodel <- tropsvm(x, y, auto.assignment = TRUE)
svmpredict <- predict(svmmodel, newx)
sum(as.vector(svmpredict) == newy)/length(newy)
# accu2 = c(accu2, sum(as.vector(svmpredict) == newy)/length(newy))
# print(accu2)
start = Sys.time()
cv.svmmodel <- cv.tropsvm(x, y, nassignment = 100, parallel = TRUE, ncores = 4)
end = Sys.time()
end - start
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
start = Sys.time()
cv.svmmodel <- cv.tropsvm(x, y, nassignment = 500, parallel = TRUE, ncores = 4)
end = Sys.time()
end - start
cv.svmpredict <- predict(cv.svmmodel, newx)
sum(cv.svmpredict == newy)/length(newy)
